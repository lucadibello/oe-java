#include <atomic>
#include <example_u.h> // include host untrusted header file for `example` enclave
#include <mutex>
#include <openenclave/host.h>
#include <sys/types.h>
#include <unordered_map>

// include stub header generated by `javah` - one stub per enclave
#include <org_oejava_oe_ExampleEnclave.h> // `example` enclave

static std::mutex g_mu;
static std::unordered_map<long, oe_enclave_t *> g_enclaves;
static std::atomic<long> g_next{1};

// --- Utility functions ---

// store enclave in map and return id
static long register_enclave(oe_enclave_t *enclave) {
  long id = g_next.fetch_add(1, std::memory_order_relaxed);
  std::lock_guard<std::mutex> lock(g_mu);
  g_enclaves[id] = enclave;
  return id;
}

// get an enclave pointer using its assigned id
static oe_enclave_t *get_enclave(long id) {
  std::lock_guard<std::mutex> lock(g_mu);
  auto it = g_enclaves.find(id);
  if (it == g_enclaves.end())
    return nullptr;
  return it->second;
}

// remove enclave from map and return its pointer
static void erase_enclave(long id, oe_enclave_t **out) {
  std::lock_guard<std::mutex> lock(g_mu);
  auto it = g_enclaves.find(id);
  if (it != g_enclaves.end()) {
    *out = it->second;
    g_enclaves.erase(it);
  }
}

// --- JNI for OeManager ---
extern "C" JNIEXPORT jlong JNICALL Java_org_oejava_oe_ExampleEnclave_create(
    JNIEnv *env, jclass, jstring jpath, jboolean debug) {
  const char *path = env->GetStringUTFChars(jpath, nullptr);
  uint32_t flags = debug ? OE_ENCLAVE_FLAG_DEBUG : 0;

  oe_enclave_t *e = nullptr;

  // Use the per-enclave constructor from example_u.h
  oe_result_t r = oe_create_example_enclave(
      path,
      OE_ENCLAVE_TYPE_AUTO, // let OE pick SGX/TDX appropriately
      flags, nullptr, 0,    // no extra settings
      &e);

  env->ReleaseStringUTFChars(jpath, path);
  if (r != OE_OK || !e)
    return 0; // 0 = failure in this API
  return (jlong)register_enclave(e);
}

extern "C" JNIEXPORT void JNICALL
Java_org_oejava_oe_ExampleEnclave_destroy(JNIEnv *env, jclass, jlong handle) {
  // destroy the enclave, and return pointer!
  oe_enclave_t *e = nullptr;
  erase_enclave(handle, &e);

  // if the enclave exists actually, destroy it
  if (e)
    oe_terminate_enclave(e);
}

extern "C" JNIEXPORT jint JNICALL
Java_org_oejava_oe_ExampleEnclave_helloworld(JNIEnv *, jclass, jlong handle) {
  oe_enclave_t *e = get_enclave((long)handle);
  if (!e)
    return (jint)OE_INVALID_PARAMETER;

  // Call the generated ECALL wrapper (from example_u.h)
  oe_result_t r = ecall_helloworld(e);
  return (r == OE_OK) ? 0 : (jint)r;
}

// --- JNI for ocalls_host.cpp ---
